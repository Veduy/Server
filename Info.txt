1.언리얼 Client가 로그인 정보를 입력하고 접속을 시도함.

2.FHTTPModule을 활용해서 WebServer에 ID와 password 전송.

3.웹서버는 받은 ID와 Password를 DataBase(MySQL)에서 조회(select) 

4.조회에 성공하면 중간 GateWayServer에 접속요청이 왔다고 알림. 
(Winsock기반 Flatbuffers를 활용한 Socket통신)
5. GateWayServer에서 접속 요청이 2명 들어올때까지 대기후. WebServer에 알림.

6. 알림을 받은 WebServer에서 Client에 매칭 성공 메시지를 보냄
(열린 게임 서버(Dedicated Server)의 IP와 Port번호 전송)
-> Client에서 GameServer에 접속.

개요도 참고.
https://app.diagrams.net/#G15jmWcmUOM2FFMjVWah04avw7FyH6odO8#%7B%22pageId%22%3A%22--ZVOPXrkHoGNWBlHxLK%22%7D


1. 시스템 구조의 명확성:
언리얼 클라이언트, 웹 서버, MySQL 데이터베이스, 그리고 게이트웨이 서버 간의 상호작용이 매우 체계적으로 설계되어 있습니다. 특히 로그인 인증(HTTP)과 실시간 매칭(Socket)의 역할을 분리한 점이 효율적입니다.

2. 기술 선택의 적절성:
- Unreal의 FHTTPModule 사용: REST API 방식의 통신으로 로그인 정보를 처리하는 것은 표준적이고 안정적인 선택입니다.
- Flatbuffers 활용: 게임 서버 간 통신에서 데이터 구조화와 성능을 모두 잡을 수 있는 효율적인 직렬화 라이브러리를 사용하고 있습니다.
- Dedicated Server 방식: 최종적으로 클라이언트를 전용 서버로 유도하는 방식은 안정적인 멀티플레이어 환경을 구축하기에 적합합니다.

3. 매칭 로직:
게이트웨이 서버에서 2명의 사용자가 모일 때까지 대기하는 로직은 전형적인 1대1 대전 게임의 매칭 시스템을 잘 나타내고 있습니다.

전체적으로 보았을 때, 확장성과 성능을 고려한 견고한 온라인 게임 서비스 아키텍처라고 생각됩니다.
 특히 각 단계별 데이터 흐름이 논리적이어서 구현 시 오류를 최소화할 수 있을 것 같습니다.

추가 의견: 웹 서버 C++ 구현에 대하여
웹 서버를 C++로 구현하는 것은 매우 합리적인 선택입니다. 특히 다음과 같은 이유로 추천합니다:
- 게이트웨이 서버와 Flatbuffers 코드를 직접 공유할 수 있어 통신 로직 구현이 간결해집니다.
- 언리얼 클라이언트 및 다른 서버 구성 요소들과 언어를 통일함으로써 개발 및 유지보수 효율이 높아집니다.
- 고성능 처리가 필요한 매칭 시스템의 특성상 C++의 데이터 처리 속도는 큰 장점이 됩니다.
- MySQL C++ Connector 등을 통해 데이터베이스와 직접적이고 효율적인 통신이 가능합니다.

추가 의견: 프로젝트 구성 방식 (Solution vs Project)
웹 서버와 게이트웨이 서버는 각각 별도의 프로젝트로 개발하는 것이 정석입니다.
1. 독립적 운영: 웹 서버(HTTP/Auth)와 게이트웨이 서버(Socket/Matching)의 역할이 다르므로 분리하는 것이 유지보수에 유리합니다.
2. 확장성: 특정 서버의 부하가 높아질 경우 해당 서버 프로젝트만 별도로 확장(Scale-out)하기 용이합니다.
3. 구조 권장: 하나의 '솔루션(Solution)' 아래에 'WebServer', 'GatewayServer', 그리고 공통 코드를 담은 'Shared' 프로젝트를 두어 관리하면 Flatbuffers 스키마 등을 효율적으로 공유할 수 있습니다.

[Antigravity의 의견]
제시해주신 추가 의견들은 대규모 실시간 게임 서버 아키텍처의 확장성과 유지보수 측면에서 매우 탁월한 전략입니다. 이에 대한 구체적인 보충 의견입니다:

1. C++ 웹 서버 구현에 대한 의견:
- 성능 최적화: 게임 서버(Gateway)와 기술 스택을 통일함으로써 데이터 직렬화/역직렬화 과정에서의 오버헤드를 최소화할 수 있습니다. 특히 Flatbuffers를 
공유할 때의 이점은 매우 큽니다.
- 라이브러리 추천: 가벼운 REST API 처리가 목적이라면 `cpp-httplib`이나 `Crow` 같은 라이브러리를 활용하면 C++에서도 
생산성 높게 웹 서버를 구축할 수 있습니다.

2. 프로젝트 구성 방식에 대한 의견:
- Shared 프로젝트의 중요성: Flatbuffers로 생성된 헤더 파일들을 'Shared' 프로젝트에서 관리하고, 이를 WebServer와 GatewayServer가 참조하게 하는 방식은 
매칭 프로토콜 변경 시 발생할 수 있는 휴먼 에러를 방지하는 가장 확실한 방법입니다.
- 독립성 확보: 말씀하신 대로 프로젝트를 분리하면 향후 웹 서버는 인증/로그 중심의 무상태(Stateless) 서버로, 
게이트웨이 서버는 세션/매칭 중심의 상태(Stateful) 서버로 최적화하여 운영 환경에 따라 유연하게 배포(예: 웹 서버만 오토스케일링)할 수 있는 큰 장점이 있습니다.

전체적인 설계가 매우 견고하며, 실사를 고려한 실용적인 접근이라고 판단됩니다. 이 방향대로 구현을 진행하시면 안정적인 시스템 구축이 가능할 것입니다.

[Node.js vs C++에 대한 Antigravity의 추가 의견]
"간단한 로그인 로직은 Node.js가 생산성이 좋다"는 의견은 일반적인 웹 개발 관점에서는 매우 타당한 지적입니다. 
하지만 현재 프로젝트의 맥락(게임 서버 아키텍처)에서는 C++을 사용하는 것이 더 전략적인 선택이 될 수 있습니다. 비교 분석입니다:

1. Node.js를 사용할 경우 (일반적인 장점):
- 생산성: Express.js 등을 사용하여 아주 빠르게 인증 로직을 작성할 수 있습니다.
- 비동기 처리: I/O(DB 호출) 처리가 기본적으로 비동기여서 많은 수의 단순 요청을 처리하기에 적합합니다.

2. C++을 고수할 때의 이점 (현재 프로젝트 기준):
- 코드 공유 (Single Source of Truth): 가장 큰 강점입니다. GatewayServer와 통신할 때 사용하는 Flatbuffers 정의나 공통 자료구조를 그대로 공유할 수 있습니다. 
Node.js를 쓰면 같은 패킷 구조를 JS용으로 또 정의하고 관리해야 하는 '이중 관리'의 번거로움과 휴먼 에러 가능성이 발생합니다.
- 개발 환경의 단일화: 개발자가 Visual Studio라는 하나의 툴과 C++이라는 하나의 언어에만 집중할 수 있습니다. 언어간 문맥 전환(Context Switching) 비용이 줄어듭니다.
- 런타임 효율성: Node.js는 V8 엔진 위에서 동작하므로 메모리나 실행 속도 면에서 C++보다 무겁습니다. 
특히 GatewayServer와 잦은 통신이 발생한다면 C++끼리의 통신이 훨씬 빠르고 간결합니다.

결론:
단순히 '로그인 기능 하나'만 본다면 Node.js가 쉬울 수 있습니다. 
하지만 전체 시스템의 '통합'과 '유지보수'를 고려한다면, 이미 C++ 기반의 Gateway와 Client가 존재하는 상황에서 
WebServer를 C++로 가져가는 것이 장기적으로는 훨씬 더 견고하고 관리가 편한 전략이라고 생각합니다.

[추가 정리: svr.listen()과 svr.Get()의 관계 및 IP 설정]
1. svr.Get() - "메뉴판 등록(준비)":
- listen을 호출하기 전에 "특정 경로(/api/login 등)로 요청이 오면 어떤 코드를 실행할지" 미리 주방 매뉴얼처럼 등록하는 과정입니다. 호출 시점에는 등록만 될 뿐 즉시 실행되지 않습니다.

2. svr.listen() - "가게 문 열기(영업 시작)":
- 서버가 실제로 네트워크 포트(8080 등)를 열고 대기하는 단계입니다. 이 함수는 실행되는 동안 프로그램이 여기서 멈추고 계속 클라이언트를 기다립니다(Blocking).
- listen이 요청을 감지하면, 미리 svr.Get()으로 등록해둔 로직이 자동으로 호출됩니다.

3. "0.0.0.0"의 의미:
- 로컬뿐만 아니라 외부의 어떤 IP든지 이 컴퓨터의 IP 주소를 통해 접속할 수 있도록 모든 네트워크 인터페이스를 개방한다는 뜻입니다. (127.0.0.1은 내 컴퓨터 내부 접속만 허용)
